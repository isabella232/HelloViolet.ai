---
layout: docs
title: 'JSDoc: Source: violet-conversations/lib/response.js'
---


  <h1 class="page-title">Source: violet-conversations/lib/response.js</h1>


<div id="generatedNav" style="display:none">
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-conversationEngine.html">conversationEngine</a></li><li><a href="module-flowScriptCompiler.html">flowScriptCompiler</a></li><li><a href="module-outputMgr.html">outputMgr</a></li><li><a href="module-response.html">response</a></li><li><a href="module-scriptParser.html">scriptParser</a></li><li><a href="module-utils.html">utils</a></li><li><a href="module-violet.html">violet</a></li><li><a href="module-violetList.html">violetList</a></li><li><a href="module-violetSrvr.html">violetSrvr</a></li><li><a href="module-violetStorePG.html">violetStorePG</a></li><li><a href="module-violetStoreSF.html">violetStoreSF</a></li><li><a href="module-violetTime.html">violetTime</a></li></ul><h3>Classes</h3><ul><li><a href="AlexaPlatform.html">AlexaPlatform</a></li><li><a href="module-conversationEngine-ConversationEngine.html">ConversationEngine</a></li><li><a href="module-conversationEngine-IntentMgr.html">IntentMgr</a></li><li><a href="module-conversationEngine-PlatformMgr.html">PlatformMgr</a></li><li><a href="module-conversationEngine-PlatformPlugin.html">PlatformPlugin</a></li><li><a href="module-conversationEngine-PlatformReq.html">PlatformReq</a></li><li><a href="module-flowScriptCompiler-FlowScriptCompiler.html">FlowScriptCompiler</a></li><li><a href="module-outputMgr-OutputMgr.html">OutputMgr</a></li><li><a href="module-response-Response.html">Response</a></li><li><a href="module-scriptParser-ScriptParser.html">ScriptParser</a></li><li><a href="module-violetList-ListWidget.html">ListWidget</a></li><li><a href="module-violetList-listWidget_.html">listWidget</a></li><li><a href="module-violetStorePG-VioletStorePG.html">VioletStorePG</a></li><li><a href="module-violetStoreSF-VioletStoreSF.html">VioletStoreSF</a></li><li><a href="StorePlugin.html">StorePlugin</a></li></ul><h3>Events</h3><ul><li><a href="global.html#event:(unnamed)">(unnamed)</a></li><li><a href="module-conversationEngine.html#~event:closeSession">closeSession</a></li><li><a href="global.html#event:Howdy">Howdy</a></li><li><a href="global.html#event:HowWork">HowWork</a></li><li><a href="global.html#event:Intro">Intro</a></li><li><a href="global.html#event:MajorIntent">MajorIntent</a></li><li><a href="global.html#event:setAlert">setAlert</a></li><li><a href="module-violetTime.html#~event:timeFwd">timeFwd</a></li><li><a href="module-violetTime.html#~event:timeReq">timeReq</a></li><li><a href="global.html#event:unsetAlert">unsetAlert</a></li><li><a href="global.html#event:WakeUp">WakeUp</a></li></ul>
</div>

<div class="codeDocs">
{% raw %}




    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* Copyright (c) 2017-present, salesforce.com, inc. All rights reserved */
/* Licensed under BSD 3-Clause - see LICENSE.txt or git.io/sfdc-license */

/**
 * Defines the Response class that forwards requests to the ConversationEngine's
 * OutputMgr which in turn will respond back to the calling-server and
 * therefore the user.
 *
 * @module response
 */
var safeEval = require('safe-eval');
var alexaAppExt = require('./alexaAppExt.js');
var debug = require('debug')('engine:response'); // to enable run as: DEBUG=engine:response OR DEBUG=*


/**
 * The Response class that forwards requests to the ConversationEngine's
 * OutputMgr which in turn will respond back to the calling-server and
 * therefore the user.
 */
class Response {
  /**
   * Constructed by the ConversationEngine before calling a Voice Script's
   * intent or when trying to resolve a goal
   */
  constructor(convoEngine, platReq) {
    this.convoEngine = convoEngine;

    this.platReq = platReq;
    this.outputMgr = platReq.outputMgr;

    this.goalStateChanged = false;

    this.paramsStore = {
      get: (varName) => {
        if (varName == 'userId') return platReq.getUserId();
        return platReq.getSlot(varName);
      },
      contains: (varName) => {
        if (varName == 'userId') return true;
        return alexaAppExt.reqContainsSlot(req, varName);
      }
    };
    var requestStore = platReq.getSession();
    this.sessionStore = {
      get: (varName, addlContext) => {
        var myContext = requestStore.getAttributes()
        if (varName == 'userId') return platReq.getUserId();
        if (varName.indexOf('.')==-1 &amp;&amp; varName.indexOf('(')==-1 &amp;&amp; varName.indexOf('=')==-1) return myContext[varName];

        // don't want to change the underlying stores attributes
        myContext = Object.assign({}, myContext);
        // potentially execute script
        myContext = Object.assign(myContext, this.convoEngine.scriptModels)
        if (addlContext)
          myContext = Object.assign(myContext, addlContext)
        debug(`\t*** store.get(${varName})... myContext: ${Object.keys(myContext)}`);
        var result;
        try {
          result = safeEval(varName, myContext);
        } catch (err) {
          console.error(err);
        }
        debug(`\t*** store.get(${varName})... result: ${result}`)
        return result;
      },
      clear: (varName) => {
        return requestStore.clear(varName);
      },
      contains: (varName) => {
        return requestStore.contains(varName);
      },
      set: (varName, val) => {
        requestStore.set(varName, val);
      }
    };
  }

  // for advanced users
  _paramsStoreReal() {return this.paramsStore;}
  _paramsStore() {return this.sessionStore;} // we are phasing out easy access to anything but the session store
  _sessionStore() {return this.sessionStore;}
  _persistentStoreReal() {return this.convoEngine.persistentStore;}
  _persistentStore() {return this.sessionStore;} // we are phasing out easy access to anything but the session store

  /**
   * Responds to the user. When an array is provided Violet picks a
   * random item - this allows responses to not be repetitive. Additionally
   * you can add input parameters directly in the response by adding them
   * in [[]]
   *
   * @example
   *  response.say('Hello')
   *  response.say(['Hello', 'Hi'])
   *  response.say('I like the name [[name]]')
   * @param {string[]} potResponses - response or array of potential
   * responses for the user
   * @param {boolean} [quick=false] - do not put a pause between the
   * previous say statement and this one
   */
  say(potResponses, quick=false) {this.outputMgr.say(this, potResponses, quick)}

  /**
   * Asks the user a question. Items being asked are placed after the say
   * statements. Additionally, only one ask is done at a time, giving the
   * user time to respond.
   *
   * @param {string[]} potResponses - response or array of potential
   * questions for the user
   */
  ask(potResponses) {this.outputMgr.ask(this, potResponses)}

  /**
   * Ends the conversation after the response. By default Violet assumes
   * that you want to close the conversation.
   *
   * @default keepConversationRunning=false
   */
  endConversation() {this.outputMgr.keepConversationRunning=false}

  /**
   * Keeps the conversation after the response. By default Violet assumes
   * that you want to close the conversation.
   *
   * @default keepConversationRunning=false
   */
  keepConversationRunning() {this.outputMgr.keepConversationRunning=true}

  contains(varStr) {
    const varVal = this.sessionStore.get(varStr);
    // debug(`**** contains(${varStr}): >${varVal}&lt;`)
    if (varVal == undefined || varVal == '') return false;
    return true;
  }

  /**
   * Gets parameter from the user
   *
   * @example
   *  violet.respondTo({
   *    expecting: 'My age is [[age]]',
   *    resolve: (response) => {
   *      var age = response.get('age');
   *      if (age &amp;&amp; age&lt;17)
   *        response.say('I need to be careful, you are a minor');
   *      else
   *        response.say('Good to meet you. I will remember the you are [[age]]');
   *  }});
   *
   * @param {string} varStr - variable name
   */
  get(varStr, addlContext = {}) {
    if (!addlContext.response) addlContext.response = this;
    return this.sessionStore.get(varStr, addlContext);
  }

  /**
   * Sets parameter value for access later
   *
   * @param {string} varStr - variable name
   * @param {Object} val - value attached to the variable
   */
  set(varStr, val) {
    return this.sessionStore.set(varStr, val);
  }

  /**
   * Clears parameter that might have been gotten from the user
   *
   * @param {string} varStr - variable name
   */
  clear(varStr) {
    return this.sessionStore.clear(varStr);
  }

  // goals support

  /**
   * Tells Violet that a goal needs to be met. These goals can be checked
   * to see if they are set by calling *hasGoal* and can be cleared by
   * calling *clearGoal*.
   * &lt;br>&lt;br>
   * Once called Violet will call any defined goals after the current
   * *resolve* method finishes.
   */
  addGoal(goal) {
    this.goalStateChanged = true;
    this.convoEngine.addGoal(this, goal);
  }

  /**
   * Checks if a goal has been set.
   */
  hasGoal(goal) {return this.convoEngine.hasGoal(this, goal);}

  /**
   * Clears goals
   */
  clearGoal(goal) {
    this.goalStateChanged = true;
    this.convoEngine.clearGoal(this, goal);
  }

  /**
   * Clears all goals
   */
  clearAllGoals() {
    this.goalStateChanged = true;
    this.convoEngine.clearAllGoals(this);
  }

  goalFilledByStore(destParamName, srcParamName) {
    if (this.contains(destParamName)) {
      return true;
    }
    if (srcParamName &amp;&amp; srcParamName!=destParamName &amp;&amp; this.contains(srcParamName)) {
      this.set(destParamName, this.get(srcParamName));
      return true;
    }
    debug('*** param not found: ', srcParamName, ' --> ', destParamName);
    return false;
  }
  isGoalFilled(paramName) {
    return this.goalFilledByStore(paramName);
  }
  ensureGoalFilled(paramName) {
    var success = this.goalFilledByStore(paramName);
    if (!success &amp;&amp; !this.hasGoal(paramName))
      this.addGoal(paramName);
    return success;
  }
}

module.exports = Response;
</code></pre>
        </article>
    </section>




{% endraw %}
</div>


<footer class="container">
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Aug 27 2019 22:19:04 GMT-0400 (EDT)
</footer>

<script> /*prettyPrint();*/ </script>
<!-- script src="scripts/linenumber.js"> </script -->
<script>
  // prism-ize: add language type and line-numbers
  var codeEntries = document.getElementsByTagName('pre');
  for (var ndx=0; ndx<codeEntries.length; ndx++) {
    var node = codeEntries[ndx];
    if (node.children.length!=1 && node.children[0].tagName!='CODE') continue;
    if (!node.className.match(/lang/)) node.className += ' language-javascript'
    if (node.className.match(/linenums/)) node.className += ' line-numbers'
  }
  // changes '<h3 class="subsection-title">Events</h3>'==><h3 class="subsection-title">Intents</h3>
  var headingEntries = document.getElementsByTagName('h3');
  for (var ndx=0; ndx<headingEntries.length; ndx++) {
    var node = headingEntries[ndx];
    if (node.className !== 'subsection-title') continue;
    if (node.textContent == 'Events') node.textContent = 'Intents';
  }
</script>
